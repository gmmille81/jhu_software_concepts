import pytest
import sys
import re
from pathlib import Path

# This module exercises the HTML produced by POST /update_analysis.
# We isolate route behavior by replacing database-dependent collaborators with
# lightweight fakes, then assert formatting expectations on returned markup.

# Ensure `src/` is importable as a top-level module path during test runs.
# The application imports `pages` directly (not `src.pages`), so this keeps
# test imports aligned with runtime import behavior.
SRC_DIR = Path(__file__).resolve().parents[1] / "src"
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))

import pages


class _FakeCursor:
    """Minimal DB cursor test double used by the route renderer.

    The Flask page rendering path executes a SQL query and then reads results
    via `fetchall()`. This fake implements only those cursor methods so the
    test can run without a real PostgreSQL connection.
    """

    def __init__(self, rows):
        # Store the rows the test wants the route to render.
        self._rows = rows

    def execute(self, _query):
        # Query text is irrelevant for this test; we only care that rendering
        # receives deterministic rows.
        return None

    def fetchall(self):
        # Return canned analysis records as if they came from answers_table.
        return self._rows

    def close(self):
        # No real resource management needed in the fake object.
        return None


class _FakeConnection:
    """Minimal DB connection test double for `pages.connect()`."""

    def __init__(self, rows):
        # Share the same in-memory result set with any cursors created from
        # this fake connection so fetch behavior remains predictable.
        self._rows = rows

    def cursor(self):
        # Return a fake cursor bound to the same canned rows.
        return _FakeCursor(self._rows)

    def close(self):
        return None


@pytest.mark.analysis
def test_update_analysis_rendered_output_includes_answer_labels(
    client, monkeypatch, assert_analysis_has_answer_labels
):
    """Verify rendered analysis includes an `Answer:` label for each result.

    This test posts to `/update_analysis`, replaces DB/analysis dependencies
    with local fakes, and checks the final HTML generated by `index.html`.
    """

    # Simulated question/answer rows that would normally come from SQL.
    rows = [
        ("Q1", "First answer"),
        ("Q2", "Second answer"),
    ]

    def fake_connect():
        # Route code calls `connect()` both before and after analysis logic.
        # Returning our fake connection keeps the test fully local.
        return _FakeConnection(rows)

    def fake_questions(_conn):
        # `questions(conn)` normally computes and stores analysis output.
        # For this test, no mutation is required.
        return None

    # Ensure route is not considered "busy" with a background DB update.
    pages.db_process = None

    # Patch module-level dependencies used inside the route function.
    monkeypatch.setattr(pages, "connect", fake_connect)
    monkeypatch.setattr(pages, "questions", fake_questions)

    # Trigger the same endpoint used by the "Update Analysis" UI button.
    response = client.post("/update_analysis")
    html = response.data.decode("utf-8")

    # Route should successfully render the analysis page.
    assert response.status_code == 200

    # Template renders each row with `<strong>Answer: </strong>...`.
    # We expect at least one `Answer:` label per row we supplied.
    assert_analysis_has_answer_labels(html, expected_min_count=len(rows))


@pytest.mark.analysis
def test_update_analysis_formats_percentages_to_two_decimals(
    client, monkeypatch, assert_analysis_has_two_decimal_numeric_value
):
    """Ensure percentage answers are rendered with exactly two decimals.

    The page route now applies final display formatting in `pages.py`, so this
    test validates the rendering contract directly: percentage-like values in
    answer text should be normalized to fixed two-decimal precision.
    """

    # Feed a one-decimal percentage to verify the renderer pads precision.
    rows = [
        ("International percentage", "52.3%"),
    ]

    def fake_connect():
        # Emulate database reads used by `_render_analysis_page`.
        return _FakeConnection(rows)

    def fake_questions(_conn):
        # Keep analysis execution side-effect free in this unit-style route test.
        return None

    # Route should proceed normally (not in "update in progress" state).
    pages.db_process = None

    # Replace route collaborators with deterministic fakes.
    monkeypatch.setattr(pages, "connect", fake_connect)
    monkeypatch.setattr(pages, "questions", fake_questions)

    # Hit the same endpoint invoked by the "Update Analysis" form submit.
    response = client.post("/update_analysis")
    html = response.data.decode("utf-8")

    # Request should succeed and return the rendered page.
    assert response.status_code == 200

    # Confirm rendered content contains normalized value with two decimals.
    # Using regex keeps the assertion focused on formatting semantics.
    assert re.search(r"52\.30%", html)
    assert_analysis_has_two_decimal_numeric_value(html)
